@article{Jiang2013,
	abstract = {
		Graph mining is an important research area within the domain of data mining.
		The field of study concentrates on the identification of frequent subgraphs within graph data sets.
		The research goals are directed at:
		  (i) effective mechanisms for generating candidate subgraphs (without generating duplicates)
		  and (ii) how best to process the generated candidate subgraphs so as to identify the desired frequent subgraphs in a way that is computationally efficient and procedurally effective.
		This paper presents a survey of current research in the field of frequent subgraph mining, and proposed solutions to address the main research issues.},
  author = {Jiang, Chuntao and Coenen, Frans and Zito, Michele},
  doi = {10.1017/S0269888912000331},
  issn = {0269-8889},
  journal = {The Knowledge Engineering Review},
  month = {March},
  number = {01},
  pages = {75--105},
  title = {{A survey of frequent subgraph mining algorithms}},
  url = {http://www.journals.cambridge.org/abstract{\_}S0269888912000331},
  volume = {28},
  year = {2013},
  annote = {

Start off with formalisms and definitions frequently used by the papers the authors cover, such as definitions for the support of a subgraph and how it defines a frequent subgraph; graph isomorphism; and tree varieties such as free trees, unordered trees, induced subtrees and embedded subtrees.
Brief overview of graph isomorphism detection, highlighting the computational complexity of graph isomorphism, subgraph isomorphism, and tree isomorphism.
In this overview is a brief descriptoin of five primary graph and subgraph isomorphic detection algorithms dating back to the late 70s / early 80s and the late 90s / early 2000s.

Brief overview of frequent subgraph and frequent subtree mining algorithms over the range of 2001 to 2008.
Broken up by how candidates are generated and how support is computed.

Describe canonical representation of graphs and trees as a means to facilitate isomorphism detection, splitting them by whether they cover graphs or trees and by whether the a canonical labelling is built using a BFS traversal or a DFS traversal.
However, they only state that if two graphs are isomorphic, then their canonical labellings are identical.
They do not, however, mention if the converse is true: if two canonical labellings are equal, then are their corresponding graphs isomorphic?

19 algorithms on Frequent Subtree Mining.
25 algorithms on Frequent Subgraph Mining.

Mentioning the nature of the graphs input and output by these algorithms: (e.g. ordered vs unordered trees, rooted vs free trees, single- vs transaction-graphs),
nature of the output graphs (e.g. exact vs inexact matching,

Goals of the works (e.g. exact vs inexact matches, reduced cost of candidate generation, mining of embedded vs induced subgraphs, maximal or closed trees, etc.).
Demonstrated applicability and usefulness in certain fields (e.g. protein-protein interactions, social networks, market analysis).

 and the methods used by these algorithsm: search space traversal and pruning, candidate subgraph/tree generation, support computation along with utilized data structures, and the performance relationships with other works as derived from experimental analysis.

BFS strategies: better capabilities for pruning the subgraph search space at the cost of higher spatial complexities; tigher upper bounds on k-subgraph candidate support values based on (k-1)-subgraph supports
DFS strategies: memory efficient at the cost of higher computational complexities

In the definition of a labelled unordered tree, there appears to be several technical errors, first in the defining of the the range of the labelling function psi, and second in the in-line definition of a right-most path of an unordered tree.
By defining it as $\psi(v_i) \to v_i$, it appears as though the labelling function is just an identity function for the vertex $v_i$.
In regards to the right-most path, it is not clear how paths in an unordered tree can be called right-most or left-most as there is no ordering for sibling nodes.

The definitions of induced subgraphs/trees and embedded subgraphs/trees is not sufficiently elaborated so as to be understood when they are discussed with FSM algorithms.
Typographical errors: Embedded subtree: no relational operator between preorder(u) and preorder(v) of nodes in the embedded subtree.
Irregular sentences.

Definition of DFCS doesn't specify the condition when a backtracking symbol is inserted into a tree's canonical label during traversal.

The authors also fail to mention that the equivalence-class based extension method is a specialization of the level-wise join, along with some notation abuses for equivalence classes.

When referring to 

Most proposed works in these fields came out in 2004 - the authors briefly describe 12 from that year - with following years showing a drop in new proposals, indicative of the field's maturation.
However, as the authors mention, there still exists open problems.
Distributed approaches to FSM haven't received much attention.
Authors haven't characterized the properties of compact subgraphs that are representative for a certain application domain, nor have many strayed away from using the frequency of subgraphs as a metric of interest.

Latest papers of which the authors include in their discussion date to 2008, which leaves a four year gap between their covered state-of-the-art and this article's papers.
The authors suggest field maturity as a cause of this gap in that no significant works have been proposed since 2007, but rather incremental improvements of existing strategies.
It would have been appropriate to provide acknowledgements to these minor improvements at least as an after-comment to those solutions on which improvements were made.


Likewise, there are some typos and inconsistencies that the authors overlooked: hyphenation ("k subgraph" in 3.2.1 vs "k-subtrees" in 3.2.2), capitalization ("$Right(T)$" vs "$left(T)$" in 3.2.5), and misabbreviations ("DLS-LS" and "DLS-DS" in 4.1), numbering in lists ("ii" is repeated twice in 5.2).
Inadequate or absent definitions: fixed topology in 5.2.3, download closure principal, induced and embedded subgraphs/trees, embedding lists, 
.
In the Hybrid Tree Mining section, I suspect the authors errantly wrote "unordered or free trees" when they intended to write "rooted or free trees".
In the section on Unordered Tree Mining, there are two typos where the wrote "DLS-LS" and "DLS-DS", when they probably intended to refer to "DFS-LS".
Scope lists, which are used by SLEUTH and TreeMiner, are not accompanied with a high-level description.
Further, they do not mention the importance of maximal trees with respect to some specific application.
It is unclear how level-wise joins are able to reduce the generation of redundant candidate subgraphs.
This is possibly due to the mixed use of k and (k-1) in the definition - the first part of the definition refers to (k-1)-subgraphs as the core of two k-subgraphs to be joined, whereas the second part of the definition seems to use (k-1)-subgraphs to refer to the two subgraphs to be joined.
This makes it difficult to realize how duplicate candidate generation is reduced by using subgraphs with the smallest-two canonical labelings.
  },
}
